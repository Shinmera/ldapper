(in-package #:org.shirakumo.ldapper)

(defun vector-append-extend (new vec)
  (loop for el across new
        do (vector-push-all el vec)))

(defmacro define-map ((a b) &body pairs)
  `(progn
     (defun ,(intern (format NIL "~a->~a" a b)) (thing)
       (ecase thing
         ,@(loop for (a b) in pairs collect (list a `',b))))
     (defun ,(intern (format NIL "~a->~a" b a)) (thing)
       (ecase thing
         ,@(loop for (a b) in pairs collect (list b `',a))))))

(defun ber-class-id (class)
  (ecase class
    (:universal   #b00000000)
    (:application #b01000000)
    (:context     #b10000000)
    (:private     #b11000000)))

(defun ber-p/c-bit (p/c)
  (ecase p/c
    (:primitive   #b00000000)
    (:constructed #b00100000)))

(defun ber-tag-type (class p/c)
  (logior (ber-class-id class) (ber-p/c-bit p/c)))

(defun make-ber-tag (class p/c number-or-command)
  (let ((byte (ber-tag-type class p/c))
	(number (etypecase number-or-command
		  (integer number-or-command)
		  (symbol (ldap-command->id number-or-command)))))
    (flet ((marr (&rest els)
             (make-array (length els) :element-type '(unsigned-byte 8) :initial-contents els)))
      (cond ((< number 31)
             (marr (logior byte number)))
	    ((< number 128)
             (marr (logior byte #b00011111) number))
	    (T (error "Length of tag exceeds maximum bounds (0-127)."))))))

(defun encode-ber-length (length vec)
  (cond ((< length 128)
         (vector-push-extend length vec))
        ((< length (- (expt 2 31) 1))
         (let ((bytes (ceiling (logcount length) 8)))
           (vector-push-extend (logior bytes #b10000000) vec)
           (loop for i downfrom (1- bytes) to 0
                 do (vector-push-extend (ldb (byte 8 i) length) vec))))
        (t (error "Length exceeds maximum bounds"))))

(defun encode-ber-sequence (tag data vec)
  (vector-append-extend (ber-tag tag) vec)
  (encode-ber-length (length data) vec)
  (vector-append-extend data vec))

(defun encode-ber-integer (tag int vec)
  (vector-append-extend (ber-tag tag) vec)
  (encode-ber-length (ceiling (logcount int) 8) vec)
  (encode-ber-length int vec))

(define-constant +ldap-version+ #x03)
(define-constant +ldap-disconnection-response+ "1.3.6.1.4.1.1466.20036")
(define-constant +ldap-control-extension-paging+ "1.2.840.113556.1.4.319")

(define-map (id ldap-command)
  (0  :bind-request)
  (1  :bind-response)
  (2  :unbind-request)
  (3  :search-request)
  (4  :search-result-entry)
  (5  :search-result-done)
  (6  :modify-request)
  (7  :modify-response)
  (8  :add-request)
  (9  :add-response)
  (10 :del-request)
  (11 :del-response)
  (12 :modify-dn-request)
  (13 :modify-dn-response)
  (14 :compare-request)
  (15 :compare-response)
  (16 :abandon-request)
  (19 :search-result-reference)
  (23 :extended-request)
  (24 :extended-response))

(define-map (id ldap-result-code)
  (0  :success)
  (1  :operations-error)
  (2  :protocol-error)
  (3  :time-limit-exceeded)
  (4  :size-limit-exceeded)
  (5  :compare-false)
  (6  :compare-true)
  (7  :auth-method-not-supported)
  (8  :strong-auth-required)
  (10 :referral)
  (11 :admin-limit-exceeded)
  (12 :unavailable-critical-extension)
  (13 :confidentiality-required)
  (14 :sasl-bind-in-progress)
  (16 :no-such-attribute)
  (17 :undefined-attribute-type)
  (18 :inappropriate-matching)
  (19 :constraint-violation)
  (20 :attribute-or-value-exists)
  (21 :invalid-attribute-syntax)
  (32 :no-such-object)
  (33 :alias-problem)
  (34 :invalid-dn-syntax)
  (36 :alias-dereferencing-problem)
  (48 :inappropriate-authentication)
  (49 :invalid-credentials)
  (50 :insufficient-access-rights)
  (51 :busy)
  (52 :unavailable)
  (53 :unwilling-to-perform)
  (54 :loop-detect)
  (64 :naming-violation)
  (65 :object-class-violation)
  (66 :not-allowed-on-leaf)
  (67 :not-allowed-on-rdn)
  (68 :entry-already-exists)
  (69 :object-class-mods-prohibited)
  (71 :affects-multiple-dsas)
  (80 :other))

(define-map (id ldap-scope)
  (0 :base)
  (1 :one)
  (2 :sub))

(define-map (id ldap-deref)
  (0 :never)
  (1 :search)
  (2 :find)
  (3 :always))

(define-map (id ldap-modify-type)
  (0 :add)
  (1 :delete)
  (2 :replace))

(define-map (id ldap-enum)
  (0 :base)
  (1 :one)
  (2 :sub)
  (0 :never)
  (1 :search)
  (2 :find)
  (3 :always)
  (0 :add)
  (1 :delete)
  (2 :replace))

(define-map (id ldap-filter)
  (0 :and)
  (1 :or)
  (2 :not)
  (3 :=)
  (4 :substring)
  (5 :>=)
  (6 :<=)
  (7 :=*)
  (8 :~=))

(define-map (id ldap-substring)
  (0 :starts-with)
  (1 :search)
  (2 :ends-with))

(defvar *ber-tags* (make-hash-table :test 'eql))

(defun ber-tag (name)
  (gethash name *ber-tags*))

(defun (setf ber-tag) (name tag)
  (setf (gethash name *ber-tags*) tag))

(setf (ber-tag :bind) (make-ber-tag :application :constructed :bind-request))
(setf (ber-tag :add) (make-ber-tag :application :constructed :add-request))
(setf (ber-tag :del) (make-ber-tag :application :primitive :del-request))
(setf (ber-tag :moddn) (make-ber-tag :application :constructed :modify-dn-request))
(setf (ber-tag :comp) (make-ber-tag :application :constructed :compare-request))
(setf (ber-tag :search) (make-ber-tag :application :constructed :search-request))
(setf (ber-tag :abandon) (make-ber-tag :application :primitive :abandon-request))
(setf (ber-tag :unbind) (make-ber-tag :application :primitive :unbind-request))
(setf (ber-tag :modify) (make-ber-tag :application :constructed :modify-request))
(setf (ber-tag :controls) (make-ber-tag :context :constructed 0))
(setf (ber-tag :referral) (make-ber-tag :context :constructed :search-request))
(setf (ber-tag :extended-response) (make-ber-tag :application :constructed :extended-response))
(setf (ber-tag :ext-name) (make-ber-tag :context :primitive 10))
(setf (ber-tag :ext-val) (make-ber-tag :context :primitive 11))
(setf (ber-tag :bool) (make-ber-tag :universal :primitive #x01))
(setf (ber-tag :int) (make-ber-tag :universal :primitive #x02))
(setf (ber-tag :str) (make-ber-tag :universal :primitive #x04))
(setf (ber-tag :null) (make-ber-tag :universal :primitive #x05))
(setf (ber-tag :enum) (make-ber-tag :universal :primitive #x0A))
(setf (ber-tag :seq) (make-ber-tag :universal :constructed #x10))
(setf (ber-tag :set) (make-ber-tag :universal :constructed #x11))

(defun encode-null (vec)
  (encode-ber-sequence :null #() vec))

(defun encode-boolean (boolean vec)
  (encode-ber-integer :bool (if boolean #xFF #x00) vec))

(defun encode-integer (int vec)
  (encode-ber-integer :int int vec))

(defun encode-enum (keyword vec)
  (encode-ber-integer :enum (ldap-enum->id keyword) vec))

(defun encode-string (string vec)
  (encode-ber-sequence :str (babel:string-to-octets string :encoding :utf-8) vec))

(defun encode-sequence (seq vec)
  (encode-ber-sequence :seq seq vec))

(defun encode-set (set vec)
  (encode-ber-sequence :set (coerce set '(vector (unsigned-byte 8))) vec))

(defun encode (thing vec)
  (etypecase thing
    ((eql 'null) (encode-null vec))
    ((member T NIL) (encode-boolean thing vec))
    (integer (encode-integer thing vec))
    (keyword (encode-enum thing vec))
    (string (encode-string thing vec))
    (vector (encode-sequence thing vec))
    (cons (encode-set thing vec))))

(defun encode* (&rest parts)
  (let ((vec (make-array 0 :adjustable T :fill-pointer T :element-type '(unsigned-byte 8))))
    (dolist (part parts vec)
      (encode part vec))))

(defun encode-message (id payload)
  (encode* (encode* id payload)))
