(in-package #:org.shirakumo.ldapper)

(defun vec ()
  (make-array 0 :adjustable T :fill-pointer T :element-type '(unsigned-byte 8)))

(defun vector-append-extend (new vec)
  (loop for el across new
        do (vector-push-extend el vec))
  vec)

(defmacro define-map ((a b) &body pairs)
  `(progn
     (defun ,(intern (format NIL "~a->~a" a b)) (thing)
       (ecase thing
         ,@(loop for (a b) in pairs collect (list a `',b))))
     (defun ,(intern (format NIL "~a->~a" b a)) (thing)
       (ecase thing
         ,@(loop for (a b) in pairs collect (list b `',a))))))

(define-map (id ber-class)
  (#b00000000 :universal)
  (#b01000000 :application)
  (#b10000000 :context)
  (#b11000000 :private))

(defun ber-p/c-bit (p/c)
  (ecase p/c
    (:primitive   #b00000000)
    (:constructed #b00100000)))

(defun ber-tag-type (class p/c)
  (logior (ber-class->id class) (ber-p/c-bit p/c)))

(defun encode-ber-tag (class p/c number-or-command &optional (vec (vec)))
  (let ((byte (ber-tag-type class p/c))
	(number (etypecase number-or-command
		  (integer number-or-command)
		  (symbol (ldap-command->id number-or-command)))))
    (cond ((< number 31)
           (vector-push-extend (logior byte number) vec))
	  ((< number 128)
           (vector-push-extend (logior byte #b00011111) vec)
           (vector-push-extend number vec))
	  (T (error "Length of tag exceeds maximum bounds (0-127).")))
    vec))

(defun decode-ber-tag (vector &optional (start 0))
  (let* ((byte (aref vector start))
         (class (id->ber-class (logand #b11000000 byte)))
         (p/c (if (logtest #b00100000 byte) :constructed :primitive))
         (id (logand #b00111111 byte)))
    (incf start)
    (when (= #b00111111 id)
      (setf id (aref vector start))
      (incf start))
    (values class p/c id start)))

(defun encode-ber-length (length &optional (vec (vec)))
  (cond ((< length 128)
         (vector-push-extend length vec))
        ((< length (- (expt 2 31) 1))
         (let ((bytes (ceiling (integer-length length) 8)))
           (vector-push-extend (logior bytes #b10000000) vec)
           (loop for i downfrom (1- bytes) to 0
                 do (vector-push-extend (ldb (byte 8 (* 8 i)) length) vec))))
        (t (error "Length exceeds maximum bounds"))))

(defun decode-ber-length (vec &optional (start 0))
  (let ((head (aref vec start)))
    (incf start)
    (if (< head 128)
        (values head start)
        (let ((bytes (logand head #b01111111))
              (int 0))
          (loop for i downfrom (1- bytes) to 0
                do (setf (ldb (byte 8 (* 8 i)) int) (aref vec start))
                   (incf start))
          (values int start)))))

(defun encode-ber-sequence (tag data &optional (vec (vec)))
  (vector-append-extend (ber-tag tag) vec)
  (encode-ber-length (length data) vec)
  (vector-append-extend data vec))

(defun decode-ber-sequence (vec &optional (start 0))
  (multiple-value-bind (length start) (decode-ber-length vec start)
    (values (subseq vec start (+ start length))
            (+ start length))))

(defun encode-ber-integer (tag int &optional (vec (vec)))
  (vector-append-extend (ber-tag tag) vec)
  (let ((bytes (max 1 (ceiling (integer-length int) 8))))
    (vector-push-extend bytes vec)
    (loop for i downfrom (1- bytes) to 0
          do (vector-push-extend (ldb (byte 8 (* 8 i)) int) vec)))
  vec)

(defun decode-ber-integer (vec &optional (start 0))
  (let ((bytes (aref vec start))
        (int 0))
    (incf start)
    (loop for i downfrom (1- bytes) to 0
          do (setf (ldb (byte 8 (* 8 i)) int) (aref vec start))
             (incf start))
    (values int start)))

(defvar +ldap-disconnection-response+ "1.3.6.1.4.1.1466.20036")
(defvar +ldap-control-extension-paging+ "1.2.840.113556.1.4.319")

(define-map (id ldap-command)
  (0  :bind-request)
  (1  :bind-response)
  (2  :unbind-request)
  (3  :search-request)
  (4  :search-result-entry)
  (5  :search-result-done)
  (6  :modify-request)
  (7  :modify-response)
  (8  :add-request)
  (9  :add-response)
  (10 :del-request)
  (11 :del-response)
  (12 :modify-dn-request)
  (13 :modify-dn-response)
  (14 :compare-request)
  (15 :compare-response)
  (16 :abandon-request)
  (19 :search-result-reference)
  (23 :extended-request)
  (24 :extended-response))

(define-map (id ldap-result-code)
  (0  :success)
  (1  :operations-error)
  (2  :protocol-error)
  (3  :time-limit-exceeded)
  (4  :size-limit-exceeded)
  (5  :compare-false)
  (6  :compare-true)
  (7  :auth-method-not-supported)
  (8  :strong-auth-required)
  (10 :referral)
  (11 :admin-limit-exceeded)
  (12 :unavailable-critical-extension)
  (13 :confidentiality-required)
  (14 :sasl-bind-in-progress)
  (16 :no-such-attribute)
  (17 :undefined-attribute-type)
  (18 :inappropriate-matching)
  (19 :constraint-violation)
  (20 :attribute-or-value-exists)
  (21 :invalid-attribute-syntax)
  (32 :no-such-object)
  (33 :alias-problem)
  (34 :invalid-dn-syntax)
  (36 :alias-dereferencing-problem)
  (48 :inappropriate-authentication)
  (49 :invalid-credentials)
  (50 :insufficient-access-rights)
  (51 :busy)
  (52 :unavailable)
  (53 :unwilling-to-perform)
  (54 :loop-detect)
  (64 :naming-violation)
  (65 :object-class-violation)
  (66 :not-allowed-on-leaf)
  (67 :not-allowed-on-rdn)
  (68 :entry-already-exists)
  (69 :object-class-mods-prohibited)
  (71 :affects-multiple-dsas)
  (80 :other))

(define-map (id ldap-scope)
  (0 :base)
  (1 :one)
  (2 :sub))

(define-map (id ldap-deref)
  (0 :never)
  (1 :search)
  (2 :find)
  (3 :always))

(define-map (id ldap-modify-type)
  (0 :add)
  (1 :delete)
  (2 :replace))

(define-map (id ldap-enum)
  (0 :base)
  (1 :one)
  (2 :sub)
  (0 :never)
  (1 :search)
  (2 :find)
  (3 :always)
  (0 :add)
  (1 :delete)
  (2 :replace))

(define-map (id ldap-filter)
  (0 :and)
  (1 :or)
  (2 :not)
  (3 :=)
  (4 :substring)
  (5 :>=)
  (6 :<=)
  (7 :=*)
  (8 :~=))

(define-map (id ldap-substring)
  (0 :starts-with)
  (1 :search)
  (2 :ends-with))

(defvar *ber-tags* (make-hash-table :test 'eql))

(defun ber-tag (name)
  (or (gethash name *ber-tags*)
      (error "No such tag ~s" name)))

(defun (setf ber-tag) (tag name)
  (when (= 1 (length tag))
    (setf (gethash (aref tag 0) *ber-tags*) name))
  (setf (gethash name *ber-tags*) tag))

(setf (ber-tag 'bind) (encode-ber-tag :application :constructed :bind-request))
(setf (ber-tag 'add) (encode-ber-tag :application :constructed :add-request))
(setf (ber-tag 'del) (encode-ber-tag :application :primitive :del-request))
(setf (ber-tag 'moddn) (encode-ber-tag :application :constructed :modify-dn-request))
(setf (ber-tag 'comp) (encode-ber-tag :application :constructed :compare-request))
(setf (ber-tag 'lookup) (encode-ber-tag :application :constructed :search-request))
(setf (ber-tag 'abandon) (encode-ber-tag :application :primitive :abandon-request))
(setf (ber-tag 'unbind) (encode-ber-tag :application :primitive :unbind-request))
(setf (ber-tag 'modify) (encode-ber-tag :application :constructed :modify-request))
(setf (ber-tag :controls) (encode-ber-tag :context :constructed 0))
(setf (ber-tag :referral) (encode-ber-tag :context :constructed :search-request))
(setf (ber-tag :extended-response) (encode-ber-tag :application :constructed :extended-response))
(setf (ber-tag :ext-name) (encode-ber-tag :context :primitive 10))
(setf (ber-tag :ext-val) (encode-ber-tag :context :primitive 11))
(setf (ber-tag :bool) (encode-ber-tag :universal :primitive #x01))
(setf (ber-tag :int) (encode-ber-tag :universal :primitive #x02))
(setf (ber-tag :str) (encode-ber-tag :universal :primitive #x04))
(setf (ber-tag :null) (encode-ber-tag :universal :primitive #x05))
(setf (ber-tag :enum) (encode-ber-tag :universal :primitive #x0A))
(setf (ber-tag :seq) (encode-ber-tag :universal :constructed #x10))
(setf (ber-tag :set) (encode-ber-tag :universal :constructed #x11))

(setf (ber-tag :pass) (encode-ber-tag :context :primitive 0))

(defun encode-null (&optional (vec (vec)))
  (encode-ber-sequence :null #() vec))

(defun encode-boolean (boolean &optional (vec (vec)))
  (encode-ber-integer :bool (if boolean #xFF #x00) vec))

(defun encode-integer (int &optional (vec (vec)))
  (encode-ber-integer :int int vec))

(defun encode-enum (keyword &optional (vec (vec)))
  (encode-ber-integer :enum (ldap-enum->id keyword) vec))

(defun encode-string (string &optional (vec (vec)))
  (encode-ber-sequence :str (babel:string-to-octets string :encoding :utf-8) vec))

(defun encode-sequence (seq &optional (vec (vec)))
  (encode-ber-sequence :seq seq vec))

(defun encode-set (set &optional (vec (vec)))
  (let ((setvec (vec)))
    (dolist (part set) (vector-append-extend part setvec))
    (encode-ber-sequence :set setvec vec)))

(defun encode-kv (attribute values &optional (vec (vec)))
  (encode attribute vec)
  (encode (mapcar #'encode (if (listp values) values (list values))) vec)
  vec)

(defun encode-alist (alist &optional (vec (vec)))
  (loop for (attribute . values) in alist
        do (encode (encode-kv attribute values) vec))
  vec)

(defun encode (thing &optional (vec (vec)))
  (typecase thing
    ((eql null) (encode-null vec))
    ((member T NIL) (encode-boolean thing vec))
    (integer (encode-integer thing vec))
    (keyword (encode-enum thing vec))
    (string (encode-string thing vec))
    (vector (encode-sequence thing vec))
    (cons (encode-set thing vec))
    (T (encode-ber-sequence (tag thing) (encode-object thing (vec)) vec))))

(defun encode* (&rest parts)
  (let ((vec (make-array 0 :adjustable T :fill-pointer T :element-type '(unsigned-byte 8))))
    (dolist (part parts vec)
      (encode part vec))))

(defun decode (vec &optional (start 0))
  (let ((tag (gethash (aref vec start) *ber-tags*)))
    (incf start)
    (case tag
      ((NIL) (multiple-value-bind (class p/c id) (decode-ber-tag vec (1- start))
               (error "Unknown tag ~a ~a ~a" class p/c id)))
      (:null (values 'null (1+ start)))
      (:bool (values (< 0 (aref vec start)) (1+ start)))
      (:int (decode-ber-integer vec start))
      (:enum (decode-ber-integer vec start))
      (:str (multiple-value-bind (octets start) (decode-ber-sequence vec start)
              (values (babel:octets-to-string octets :encoding :utf-8) start)))
      (:seq (decode-ber-sequence vec start))
      (:set (decode-ber-sequence vec start))
      (T (multiple-value-bind (length start) (decode-ber-length vec start)
           (decode-object tag vec start (+ start length)))))))

(defun decode* (vec &optional (start 0) (end (length vec)))
  (values (loop while (< start end)
                collect (multiple-value-bind (object next) (decode vec start)
                          (setf start next)
                          object))
          start))

(defmethod decode-object ((tag (eql :bind)) vec start end)
  (decode* vec start end))

(defmethod decode-object ((tag (eql :pass)) vec start end)
  (values (babel:octets-to-string vec :start start :end end :encoding :utf-8)
          end))

(defun encode-message (id payload)
  (encode (encode* id payload)))

(defun decode-message (vec &optional (start 0))
  (multiple-value-bind (message start) (decode vec start)
    (multiple-value-bind (id off) (decode message)
      (values id (decode message off) start))))

(defclass command () ())

(defgeneric tag (command))
(defgeneric decode-object (tag vec start end))
(defgeneric encode-object (command vec))

(defmethod decode-object ((tag symbol) vec start end)
  (decode-object (make-instance tag) vec start end))

(defmethod decode-object :around ((command command) vec start end)
  (values command (call-next-method)))

(defmethod encode-object :around (object (vec vector))
  (call-next-method)
  vec)

(defmethod tag ((command command))
  (type-of command))

;; FIXME: bad macro, not pure
(defmacro with-decoding (parts (vec &rest decode-args) &body body)
  (let ((p (gensym "PARTS"))
        (s (gensym "START")))
    `(multiple-value-bind (,p ,(or (first decode-args) s)) (decode* ,vec ,@decode-args)
       ,@(unless (first decode-args) `((declare (ignore ,s))))
       (destructuring-bind ,parts ,p
         ,@body))))

(defclass bind (command)
  ((version :initarg :version :accessor version) 
   (user :initarg :user :accessor user)
   (pass :initarg :pass :accessor pass)))

(defmethod decode-object ((command bind) vec start end)
  (with-decoding (version user pass) (vec start end)
    (setf (version command) version)
    (setf (user command) user)
    (setf (pass command) pass)
    start))

(defmethod encode-object ((command bind) vec)
  (encode (version command) vec)
  (encode (user command) vec)
  (encode-ber-tag :context :primitive 0 vec)
  (vector-append-extend (babel:octets-to-string (pass command) :encoding :utf-8) vec))

(defclass unbind (command)
  ())

(defmethod decode-object ((command unbind) vec start end)
  (with-decoding (null) (vec start end)
    (assert (eql 'null null))
    start))

(defmethod encode-object ((command unbind) vec)
  (encode 'null vec))

(defclass abandon (command)
  ((id :initarg :id :accessor id)))

(defmethod decode-object ((command abandon) vec start end)
  (with-decoding (id) (vec start end)
    (setf (id command) id)
    start))

(defmethod encode-object ((command abandon) vec)
  (encode (id command) vec))

(defclass add (command)
  ((domain-name :initarg :domain-name :accessor domain-name) 
   (attributes :initarg :attributes :accessor attributes)))

(defmethod decode-object ((command add) vec start end)
  (with-decoding (domain-name attributes) (vec start end)
    (setf (domain-name command) domain-name)
    (with-decoding (&rest attributes) (attributes)
      (setf (attributes command) (loop for attrvec in attributes
                                       for (attribute valvec) = (decode* attrvec)
                                       collect (cons attribute (decode* valvec)))))
    start))

(defmethod encode-object ((command add) vec)
  (encode (domain-name command) vec)
  (encode (encode-alist (attributes command)) vec))

(defclass del (command)
  ((domain-name :initarg :domain-name :accessor domain-name)))

(defmethod decode-object ((command del) vec start end)
  (setf (domain-name command) (babel:octets-to-string vec :start start :end end :encoding :utf-8)))

(defmethod encode-object ((command del) vec)
  (vector-append-extend (babel:string-to-octets (domain-name command) :encoding :utf-8) vec))

(defclass moddn (command)
  ((domain-name :initarg :domain-name :accessor domain-name)
   (new-domain-name :initarg :new-domain-name :accessor new-domain-name)
   (delete-old-p :initarg :delete-old-p :accessor delete-old-p)
   (new-sup :initarg :new-sup :accessor new-sup)))

(defmethod decode-object ((command moddn) vec start end)
  (with-decoding (domain-name new-domain-name delete-old-p &optional new-sup) (vec start end)
    (setf (domain-name command) domain-name)
    (setf (new-domain-name command) new-domain-name)
    (setf (delete-old-p command) delete-old-p)
    (setf (new-sup command) new-sup)
    start))

(defmethod encode-object ((command moddn) vec)
  (encode (domain-name command) vec)
  (encode (new-domain-name command) vec)
  (encode-boolean (delete-old-p command) vec)
  (when (new-sup command)
    (encode (new-sup command) vec)))

(defclass compare (command)
  ((domain-name :initarg :domain-name :accessor domain-name)
   (attribute :initarg :attribute :accessor attribute)
   (value :initarg :value :accessor value)))

(defmethod decode-object ((command compare) vec start end)
  (with-decoding (domain-name pair) (vec start end)
    (setf (domain-name command) domain-name)
    (destructuring-bind (attribute value) (decode* pair)
      (setf (attribute command) attribute)
      (setf (value command) value)
      start)))

(defmethod encode-object ((command compare) vec)
  (encode (domain-name command) vec)
  (encode (encode* (attribute command) (value command)) vec))

(defclass modify (command)
  ((domain-name :initarg :domain-name :accessor domain-name) 
   (modifications :initarg :modifications :accessor modifications)))

(defmethod decode-object ((command modify) vec start end)
  (with-decoding (domain-name modifications) (vec start end)
    (setf (domain-name command) domain-name)
    (with-decoding (&rest modifications) (modifications)
      (setf (modifications command) (loop for modvec in modifications
                                          for (type attrvec) = (decode* modvec)
                                          for (attribute valvec) = (decode* attrvec)
                                          collect (list* (id->ldap-modify-type type) attribute (decode* valvec)))))
    start))

(defmethod encode-object ((command modify) vec)
  (encode (domain-name command) vec)
  (let ((modifications (vec)))
    (loop for (type attribute . values) in (modifications command)
          for mod-seq = (vec)
          do (encode type mod-seq)
             (encode (encode-kv attribute values) mod-seq)
             (encode mod-seq modifications))
    (encode modifications vec)))

(defclass lookup (command)
  ((filter :initarg :filter :accessor filter)
   (base :initarg :base :accessor base)
   (scope :initarg :scope :accessor scope)
   (deref :initarg :deref :accessor deref)
   (size :initarg :size :accessor size)
   (timestamp :initarg :timestamp :accessor timestamp)
   (types-p :initarg :types-p :accessor types-p)
   (attributes :initarg :attributes :accessor attributes)
   (paging-size :initarg :paging-size :accessor paging-size)
   (paging-cookie :initarg :paging-cookie :accessor paging-cookie)))

(defmethod decode-object ((command lookup) vec start end)
  )

(defmethod encode-object ((command lookup) vec)
  (encode (base command) vec)
  (encode (scope command) vec)
  (encode (deref command) vec)
  (encode (size command) vec)
  (encode (timestamp command) vec)
  (encode-boolean (types-p command) vec)
  ()
  (encode (apply #'encode* (attributes command)) vec)
  ())
